\chapter{Основная часть}

\section{Подход к технической реализации}

Предположим, нужно добавить какую-то новую функциональность в язык. Есть два принципиально разных способа это сделать:
\begin{itemize}
	\item использовать существующие средства языка
	\item изменять синтаксис языка (например, добавить новые ключевые слова)
\end{itemize}

У обоих этих подходов есть как положительные, так и отрицательные стороны. Изменение синтаксиса языка приводит к изменению грамматики языка, из чего следует невозможность использования многих существующих инструментов для разработки с использованием этого языка, таких как компиляторы, среды разработки, различные анализаторы кода. Но с другой стороны этот подход позволяет добавлять в язык развитую систему выразительных средств. Использование же существующих средств языка ограничивает свободу введения новых концепций, но этот подход обычно гораздо проще в реализации.

В случае Java есть несколько способов добавить поддержку неизменяемости объектов в язык. В работе IGJ это сделано с помощью добавления дополнитьельного типового параметра ко всем классам. Но это выглядит очень громоздко и трудно читаемо. Более того, информация о типовых параметрах остуствует в скомпилированных файлах, то есть информация об изменяемости также будет доступна только в исходном коде. Другой варинат -- использование аннотаций. 

Аннотация в Java -- это вид синтаксических методанных, которые могут быть добавлены в исходный код. Они могут быть доступны на этапе компилляции, встроены в класс-файлы, а также могут использоваться JVM во время исполнения программы. В Java 7 аннотации можно применять к пакетам, классам, методам, переменным и параметрам. 

Как справедливо отмечают некоторые авторы, аннотации в том виде, в котором они реализованы в Java 7, не достаточно мощны для того, чтобы добавить поддержку контроля за изменяемостью объектов, так как в нынешней реализации нельзя аннотировать типы. Но уже в Java 8 такая поддержка появится, поэтому в данной работе именно аннотации используются для выражения неизменяемости объектов.

\section{Система аннотаций}

В данной работе каждая ссылка имеет модификатор изменяемости, который определяет, может ли быть изменено ее абстрактное состояние. Этот моификатор определяется на уровне исходного кода, анализуруется на этапе компиляции и может иметь одно из четырех значений: Mutable, Immutable, ReadOnly или Isolated. На изображении ниже представлена иерархия параметров неизменяемости. 

Выражение $A \preceq B$ будем тракторвать как "A является наследником В". В данном случае, например, $Mutable \preceq ReadOnly$. Также будем считать, что если $A \preceq B$, где А и B - модификаторы изменяемости, то $@A С \preceq @B C$, где С - некий тип.

\subsection{Ссылочная неизменяемость}

Для поддержки ссылочной неизменяемости достаточно двух модификаторов: Mutable и ReadOnly. Состояние объекта не может быть изменено через ReadOnly ссылку. Попытка присвоить поле через ReadOnly ссылку или вызвать на ней меняющий объект метод приведет к ошибке компиляции:

\begin{lstlisting}[caption=Mutable и RadOnly ссылки, label=code:mutable_vs_readonly]
@ReadOnly Person roPerson = ...;
String address = roPerson.address; // OK: reading field is always permitted
roPreson.address = "new address"; // Error: field can't be assigned through ReadOnly referernce

@Mutable Person mPreson = ...;
mPerson.address = "new address"; // OK: mPerson is mutable, so field can be assigned
\end{lstlisting} 

Пусть I(x) - это функция, которая принимает класс, тип или ссылку и возвращает ее модификатор изменяемости. Тогда формально вышеизложенное правило может быть написано следующим образом:

\begin{Rule}\label{rule:assign_field}
o.someField = ... разрешено тогда и только тогда, когда $I(o) = Mutable$ 
\end{Rule}

Изменяемая ссылка может быть передана везде, где ожидается неизменяемая ссылка. Таким образом, @Mutable Person является наследником @ReadOnly Person.

\textit{рисунок} 

\subsection{Аннотации на методах}

Изменяемость this зависит от контекста, а именно от метода, в котором появляется this. По умолчанию все методы изменяют объект, на котором вызываются. В таких методах this будет иметь модификатор Mutable. Те методы, которые не изменяют объект, на котором они вызываются, должны быть помечены аннотацией @Const (по аналогии с C++), this в этих методах будет иметь модификатор @ReadOnly.

На ReadOnly ссылках нельзя вызывать методы, которые меняют объект, на котором вызываются. Формально это правило может быть описано так:

\begin{Rule}\label{rule:invoke_method}
o.m(...) разрешено, если $I(o) \preceq I(m)$, где I(m) -- модификатор изменяемости this в этом методе.
\end{Rule}

Требуется, что $I(o) \preceq I(m)$ а не $I(o) = I(m)$ для того, чтобы через изменяемую ссылку можно было вызывать методы, не меняющие объект. 

Рассмотрим на примере применение этих правил.

\begin{lstlisting}[caption=Аннотации на методах, label=code:method_annotations]
class Person {
    String name;
    @AsClass Date dateOfBirth;	
    
    public Person(String name, Date dateOfBirth) {
    	this.name = name;
    	this.dateOfBirth = dateOfBirth;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    @Const
    public String getName() {
        return name;
    }
    
    @AsClass
    @Const
    public Date getDateOfBirth() {
        return dateOfBirth;
    }
    
    @Const 
    public boolean wasBornInYear(int year) {
    	return dateOfBirth.getYear() == year;
    }
    
    public void setYearOfBirth(int year) {
        dateOfBirth.setYear(year);
    }
    
    public static void print(@ReadOnly Person person) {
        ...
    }
}
\end{lstlisting} 

Присваивание this.name = name в 11 строчке разрешено, так как $I(this) = I(setName) = Mutable$, а согласно правилу \ref{rule:assign_field} через Mutable ссылку можно присваивать значение поля. Это присваивание было бы не разрешено, если бы оно было перемещено  на 16 строчку, так как this является ReadOnly ссфлкой в контексте метода getName. Вызов метода setYear на 31 строчке зарешен согласно правилу \ref{rule:invoke_method}, так как $I(dateOfBirth) = I(this) \proceq I(setyearOfBirth)$. Этот вызов метода не был бы разрешен на 27 строчке, так как в контексте метода wasBornInYear $I(this) = ReadOnly$. Статический метод print на 34 строчке принимает объект класса Person с любым модификатором изменяемости. 

Поле dateOfBirth проаннотировано AsClass. Это значит, что его модификатор изменяемости зависит от того, какой можификатор у this. Соответсвенно и результатом работы метода getDateOfBirth будет либо Mutable ссылка (если сам он был вызван на объекте, доступном по Mutable ссылке), либо ReadOnly ссылка в противном случае:

\begin{lstlisting}[caption=Использование аннотации AsClass, label=code:as_class]
	@ReadOnly Person roPerson = ...;
	int year = roPerson.getDateOfBirth().getYear(); // OK: I(getYear) = ReadOnly
	roPerson.getDateOfBirth().setYear(2000); // OK: I(roPerson.getDateOfBirth()) = I(roPerson) = ReadOnly
	
	@Mutable Person mPerson = ...;
	mPerson.getDateOfBirth().setYear(2000); // OK: I(mPerson.getDateOfBirth()) = I(mPerson) = Mutable
}
\end{lstlisting} 

Аннотация AsClass может встречаться на полях метода, локальных переменных, возвращаемых значениях нестатических методов и параметрах методов.

\subsection{Перегрузка методов}

При перегрузке методов, метод класса-потомка должен оставить прежним или усилить модификатор неизменяемости, который имеет this в данном методе. 

\begin{Rule}\label{rule:override_method}
Если метод m' перегружет метод m, то $I(m) \proceq I(m')$
\end{Rule}

Например, метод класс-потомок может добавить аннотацию Const к перегружаемому методу, если ее не было в классе-предке, но не наоборот. 

\subsection{Объектная неизменяемость}

Хотя ReadOnly ссылки запрещают менять объект, на который ссылаются, никто не гарантирует, что этот объект не будет изменен при помощи какой-либо другой ссылки. Это хорошо иллюстрирует слудющий пример:

\begin{lstlisting}[caption=Изменение объекта\, хранимого по ReadOnly ссылке, label=code:change_ro_object]
	@Mutable Person person = ...;
	person.setYearOfBirth(2000);
	@ReadOnly Person roPerson = person; // OK: @ReadOnly Person is supertype for @Mutable person
	System.out.println(roPerson.getyearOfBirth()); // 2000 will be printed
	person.setyearOfBirth(2013);
	System.out.println(roPerson.getyearOfBirth()); // 2013 will be printed			
}
\end{lstlisting} 

При этом частно возникает ситуация, когда хочется не только гарантировать, что по данной ссылке нельзя менять объект, но и то, что данный объект вообще нельзя менять. Такие гарантии могут быть полезны, например, при многопоточном программировании -- если про объект известно, что он неизменяемый, то к нему можно безопасно обращаться из нескольких потоков без дополнительной синхронизации. Разработанная в данной работе система может давать такую гарантию: Mutable ссылка указывает на изменяемый объект, а Immutable ссылка - на неизменяемый. 

\begin{lstlisting}[caption=Mutable и Immutable ссылки, label=code:mutable_vs_immutable]
	@Mutable Person person = ...;
	@Immutable Person iPerson = person; // Error: @Immutable Person is not supertype for @Mutable Person
	@ReadOnly Person roPerson = iPerson; // OK: @ReadOnly Person is supertype for @Immutable Person
}
\end{lstlisting} 

Из данного примера видна разница между ReadOnly и Immutable ссымлками: если ReadOnly ссылка может указывать как на изменяемый, так и на неизменяемый объект, то Immutable ссылка всегда указывает только на неизменяемый объект.  

\subsection{Исключение полей из абстрактного состояния объекта}

Одной из целей данной работы былы разработка системы типов, которая бы давала гарантии относительно абстрактного состояния объектов, а не о конкретной его реализации. Транзитивные гарантии неизменяемости для всех полей объекта в некоторых случаях могут быть слишком сильны. Например, поля, исползуемые для кэширования не являются частью абстрактного состояния. Таким образом, необходим механизм, позволяющий исключать некоторые поля из абстрактного состояния объекта. В данной работе для этого используется аннотация @Transient, которое обозначает, что данное поле не является частью абстрактного состояния. 

Многие авторы разделяют два способа исключения поля из абстрактного состояния:
\begin{itemize}
\item{Значение поля может быть переприсвоено даже через неизменяемую ссылку, но само значение в этом случае не может быть изменено}
\item{Значение поля не может быть переприсвоено, но при этом исходное значение может быть изменено даже через ReadOnly ссыллку}
\end{itemize}
Этот подход кажется несколько избыточным: такая тонкая настройка изменяемости нужна крайне редко и при этом приводит к некоторым проблемам в системе типов, которые приходится решать введением новых правил, которые частно выглядят синтетически.

\subsection{Вложенные классы}

Статические вложенные классы подчинябтся всем тем же правилам, что и обычные классы. Нестатические вложенные классы имеют дополнительную ссылку на this. Изменяемость this зависит от того, в каком методе он вызван. Метод нестатического вложенного класса может быть объявлен как Const только если он не меняет обе ссылки this (свою и внешнего класса).

\subsection{Неизменяемые классы}

Существуют классы, все представители которых. Таковыми являются, например, java.lang.String и большинство потомков java.lang.Number. Обычно тот факт, что все представители некого класса являются неизменяемыми, отражается в документации. В данно работе для этого разрешено использовано аннотацию Immutable. Все методы класса, объявленного как Immutable будут обрабатываться так, как будто они аннотированы как Const.

\subsection{Создание циклов неизменяемых объектов}

Большинсвто неизменяемых объектов, тем ни менее, модифицируются во время фазы их конструирования. Часто эта фаза локализуема непостредственно в конструкторе объекта -- например, в конструктор неизменяемогосписка может быть пнабор объектов, которыми этот список нужно заполнить, и после отработки конструктора объект уже можно по праву считать неизменяемым. Несмотря на то, что для большинства объектов фаза их создания заканчивается посе отработки конструктора, бывают случаи, когда такой подход неприменим. Одним из наиболее ярких примеров этого могут служить неизменяемые циклические структуры данных. Рассмотрим следующий пример:

\begin{lstlisting}[caption=CircularListNode.java, label=code:circular_list_node]
class CircularListNode {
    @AsClass CircularListNode prev;
    @AsClass CircularListNode next;
    
    @Immutable
    public static CircularListNode createTwoNodeList() {
    	// ???
    }
}
\end{lstlisting} 

Необходимо реализовать метод createTwoNodeList, который вернет неизменяемый циклический список из двух элементов. Это сделать не получится, так как "соединить" элемента списка друг с другом придется уже после создания. Можно, конечно, возвращать не Immutable ссылку, а ReadOnly:
 
\begin{lstlisting}[caption=CircularListNode.java, label=code:circular_list_node_ro]
class CircularListNode {
    @AsClass CircularListNode prev;
    @AsClass CircularListNode next;
    
    @ReadOnly
    public static CircularListNode createTwoNodeList() {
    	@Mutable CircularListNode n1 = new CircularListNode();
        @Mutable CircularListNode n2 = new CircularListNode();
    	
        n1.next = n2;
        n1.prev = n2;
        n2.next = n1;
        n2.prev = n1;
    
        return n1;  
    }
}
\end{lstlisting} 

Не трудно видеть, что этом случае созданный список фактически будет неизменяемым, так как после завершения этапа создания, на него не останется ни одной Mutable ссылки. Но этот момент необходимо было бы дополнительно отражать в документации, также результат работы этого метода не мог бы быть использован для передачи в метод, который требует именно Immutable ссылку. 

Ключевым моментов в объяснении того, почему именно результатом работы метода createTwoNodeList будет неизмяенемый объект было следующее утверждение: \textit{после завершения этапа создания, на него не останется ни одной Mutable ссылки}. На самом деле, важно еще и то, что Mutable ссфлок не осталось и на другие транзитивно-достижимые из данного объекта объекты. И так как в данном случае это утверждение верно, то объект фактически является неизменяемым. Таким образом, можно прийти к определению изолированной ссылки:

\begin{Def}\label{isolated_ref}
Изолированная ссылка (Isolated) -- это ссылка на изолированный граф объектов. Объекты внутри изолиованного графа могут ссылаться друг на драга, но существует только одна внешняя не-ReadOnly ссылка на такой граф. Все пути к не-неизменяемым объектам, доступным через isolated ссылку идут через это ссылку кроме путей, идущих по ReadOnly ссылкам.
\end{Def}

\textit{рисуночек} 

Введение такого понятия, как изолированная ссылка может быть единовременно конвертирована в Mutable или Immutable ссылку, так как на граф объектов, достижимых через нее, есть только ReadOnly ссылки, которые не гарантируют ничего относительно этого графа. 

Превращение Isolated ссфлки в Mutable ссфлку происходит тревиальным образом:

\begin{lstlisting}[caption=Превращение Isolated ссылки в Mutable, label=code:isolated_to_mutable]
@Isolated Person p = ...;
p.setName("Bob");
\end{lstlisting} 

Здесь в строке 2 происходит неявное преобразование модификатора изменяемости p в Mutable.

Isolated ссылка может быть также единовременно сконвертирована в Immutable ссылку.

\begin{lstlisting}[caption=Превращение Isolated ссылки в immutable, label=code:isolated_to_immutable]
@Isolated Person p = ...;
@Immutable imp = p;
p.setName("Alice"); // Error
\end{lstlisting} 

Не смотря на то, что p была изначальнообъявлена как Isolated, после присовения в imp она была преведена к Immutable и объект, на который она ссылается, не может быть изменен.

Важный момент заключается в том, что превращение Isolated ссылки в Mutable не является необратимым. Например, следующий пример не содержит ошибок компиляции:

\begin{lstlisting}[caption=Превращение Isolated ссылки в Mutable и обратно, label=code:isolated_to_mutable_and_back]
@Isolated
public IntBox increment(isolated IntBox b) { 
    b.value++; 
    return b;
}
\end{lstlisting}

В данном случае превращение ссылки обратно в Isolated возможно, так как фактически ссылка b осталась изолированной. В работе \textit{добавить ссылку} было сформулировано следующее правило, которое обуславливает, может ли Mutable ссылка быль превращена обратно в Isolated после выполнения некой операции:

\begin{Rule}\label{rule:convert_isolated}
Если входной контекст выражения не содержит Mutable ссылок, а выходной контекст выражения содержит одну Mutable ссылку, то эта ссылка может быть превращена обратно в Isolated.
\end{Rule}

Действительно, в случае, когда язык запрещает иметь глобальные изменяемые значения, а также исключать поля из абстрактого состояния объекта, это правило работает. Если после проведения какой-либо операции появилась одна Mutable ссылка, а перед началом операции ни одной Mutable ссылки не существовало, то эта ссылка либо является ссылкой на объект, на который других ссылок не существует, либо на объект, котоырй был только что создан. 

Но запрет на существование глобальных изменяемых переменных кажется слишком сильным ограничением, так как в существующем коде уже имеется большое количесвто подобных примеров. При этом очевидно, что существуют методы, которые никаким образом не взаимодействуют с глобальными изменяемыми переменными и полями, которые исключены из абстрактного состояния объекта. Будем называть такие методы чистыми и аннотировать их как @Pure. Тогда вышепреведенное правило применимо в контексте Pure метода. Остальные типовые правила для Isolated ссылок будут аналогичны тем, что приведены в \textit{ссылочка} 

Рассмотрим, каким образом введение Isolated ссылок может решить проблему с созданием циклов неизменяемых объектов:

\begin{lstlisting}[caption=CircularListNode.java, label=code:circular_list_node_isolated]
class CircularListNode {
    @AsClass CircularListNode prev;
    @AsClass CircularListNode next;
    
    @Mutable
    @Pure
    private static CircularListNode doCreateTwoNodeList() {
    	@Mutable CircularListNode n1 = new CircularListNode();
        @Mutable CircularListNode n2 = new CircularListNode();
    	
        n1.next = n2;
        n1.prev = n2;
        n2.next = n1;
        n2.prev = n1;
    
        return n1;  
    }
    
    @Immutable
    public CircularListNode createTwoNodeList() {
        @Isolated CircularListNode result = doCreateTwoListNode();
        return result;
    }
}
\end{lstlisting} 

\section{Алгоритм вывода аннотаций}

При разработке реальных приложений обычно используется большое количество библиотечного кода. Проаннотировать весь этот код аннотациями неизменяемости не представляется возможным. Чтобы разработанную в данной работе систему аннотаций можно было использовать в реальных приложениях, нужно обеспечить возможность работать с непроаннотированным кодом. Самое простое решение -- это объявить, что все методы меняют объекты, на которых вызываются. Но тогда практически все объекты во вновь написанном коде (уже с использованием модификаторов неизменяемости) окажутся Mutable. 

Таким образом необъходимо разработать способ проаннотировать существующий в автоматическом режиме. Далее представлено описание алгоритма, который теоретически позволяет с той или иной точностью вывести соответсвующие аннотации по байткоду. 

Пусть необходимо проаннотировать байт-код некой библиотеки. При этом, возможно, аннотации на некоторых методах или их параметрах уже известны (например, в документации явно написано, что все экземпляры некого класса являются неизменяемыми). Считается, что эти наперед данный аннотации проставлены правильно. Далее рассмотрены этапы аннотирования кода этой библиотеки.

\subsection{Вычисление полей, не входящих в абстрактное состояние объекта}

На первом этапе анализа все поля, объявленные как transient помечаются аннотацией @Transient. Все остальные поля помечаются как @AsClass. 

\subsection{Анализ методов на чистоту}

На этом этапе необходимо проставить аннотации @Pure на тех методах, которые не взаимодействуют с глобальными Mutable перемеными и полями, помеченными как @Transient. Результатом работы алгоритма будет множество методов, которые можно пометить как @Pure. 

Пусть M -- множество всех аннотируемых методов, определим функицю $results: M \rightarrow {Pure, NotPure, Unknown}$, которая для каждого метода возвращает то, что в на данном этапе известно о его чистоте:
\begin{itemize}
\item Pure -- известно, что метод можно проаннотировать как @Pure
\item NotPure -- известно, что метод нельзя проаннотировать как @Pure
\item Unknown -- еще не известно, можно или нельзя проаннотировать метод как @Pure
\end{itemize}

Определим также функцию $count: M, results \rightarrow int$ такую, что она возвращает количесвто методов m, для которых $results(m) = Unknown$. Тогда в упрощенном виде псевдокод алгоритма будет выглядеть следующим образом:

\begin{lstlisting}[caption=Анализ чистоты методов, label=code:purity]
analyze(M, results)
    prevUnknown = count(M, results);
    while True 
        for m in M 
            if resluts[m] == Unknown
                results[m] = analyzeMethod(results, x)
        c = count(M, results)
        if c == prevUnknown 
        	return M.filter(\m.(results(m) == Pure))        
        else 
            revUnknown = c
\end{lstlisting}

То есть, методы анализирутся до тех пор, пока за очередную итерацию не станет известно ничего нового. По теореме о неподвижной точке (?) данный флгоритм завершит свою работу, так как функция count не возрастает (если однажды было вычислено значение функции reaults для некоторого метода m, отличное от Unknown, то оно уже больше никогда не будет изменено) и ограничена (количесвто методов не может быть меньше нуля). 

Очевидно, что практически любая библиотека использует методы, не входящие в ее состав (например, методы из стандартной библиотеки). Пусть MExt -- множество всех таких методов. Тогда определим функцию $ext: MExt \rightarrow {Pure, NotPure}$, которая возвращет Pure, если известно, что на методе стоит аннотация @Pure, а иначе возвращает NotPure. 

Теперь рассмотрим, как должен быть устроен код функции analyzeMethod. При анализе метода на чистоту по очереди анализируются все инструкции байт-кода этого метода. 
\begin{itemize}
\item Если встречается инструкция PUTSTATIC и при этом не известно, что поле, в которое происходит запись, имеет модификатор изменяемости ReadOnly, то возращается NotPure
\item Eсли встречается инструкция GETSTATIC и при этом не известно, что поле, занчение которого считывается, имеет модификатор изменяемости Mutable, то возвращается NotPure
\item Если встречается инструкция PUTFIELD и при этом поле, в которое происходит запись, проаннотировано как @Transient, то возвращается NotPure
\item Если встручается инструкция GETFIELD и при этом поле, значение которого читается, является @Transient и @Mutable, то возвращается NotPure
\item Если встречается инструкция вызова метода m, то вычисляется значение функции $result = m \in M ? results(m) : ext(m)$. Если result != Pure, то врзвращается result
\item Во всех остальных случаях возвращаем Pure
\end{itemize} 

\subsection{Вычисление модификаторов изменяемости} 

Для каждого метода нужно вычислить селедующие модификаторы неизменяемости:
\begin{itemize}
    \item Аннотации на параметрах метода
    \item Аннотация на возвращаемом значении
    \item Для нестатических методов необходимо вычислить, какой модификатор имеет this в контексте этого метода
\end{itemize}

Во всех трех случаях будем вычислять не непосредственно модификаторы неизменяемости, а те границы, в которых они могут лежать. После этого для параметров методов выберем наиболее общий модификатор, а для возвращаемого знаяения -- наиболее конкретный. Те методы, в которых ReadOnly будет попадать в границы, вычисленные для this, пометим как @Const.

\textit{добавить}

\subsection{Вычисление неизменяемых классов}

Если в процессе анализа оказалось, что какой-либо класс не имеет методов, не помеченных @Const, то данный класс можно автоматически пометить как @Immutable. При автоматическом аннотировании кода имеет смысл почемать как @Immutable только final классы, так как потомки класса могут добавить в интерфейс свои неконстантные методы, и, если бы класс был при этом помечен как @Immutable, добавление неконстантных методов в классах-потомках привело бы к ошибке компиляции.

\section{Сравнение с существующими подходами}

В данной работе удалось разработать систему аннотаций, 
























